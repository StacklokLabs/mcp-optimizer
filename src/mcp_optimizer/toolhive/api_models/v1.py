# generated by datamodel-codegen:
#   filename:  http://127.0.0.1:8080/api/openapi.json
#   timestamp: 2025-09-30T12:49:55+00:00

from __future__ import annotations

from typing import Optional

from pydantic import BaseModel, Field

from . import client, core
from . import groups as groups_1
from . import permissions
from . import registry as registry_1
from . import secrets as secrets_1


class UpdateRegistryRequest(BaseModel):
    allow_private_ip: Optional[bool] = Field(
        None, description='Allow private IP addresses for registry URL'
    )
    local_path: Optional[str] = Field(None, description='Local registry file path')
    url: Optional[str] = Field(None, description='Registry URL (for remote registries)')


class UpdateRegistryResponse(BaseModel):
    message: Optional[str] = Field(None, description='Status message')
    type: Optional[str] = Field(None, description='Registry type after update')


class BulkClientRequest(BaseModel):
    groups: Optional[list[str]] = Field(
        None, description='Groups is the list of groups configured on the client.'
    )
    names: Optional[list[str]] = Field(
        None, description='Names is the list of client names to operate on.'
    )


class BulkOperationRequest(BaseModel):
    group: Optional[str] = Field(
        None, description='Group name to operate on (mutually exclusive with names)'
    )
    names: Optional[list[str]] = Field(
        None, description='Names of the workloads to operate on'
    )


class ClientStatusResponse(BaseModel):
    clients: Optional[list[client.MCPClientStatus]] = None


class CreateClientRequest(BaseModel):
    groups: Optional[list[str]] = Field(
        None, description='Groups is the list of groups configured on the client.'
    )
    name: Optional[str] = Field(
        None, description='Name is the type of the client to register.'
    )


class CreateClientResponse(BaseModel):
    groups: Optional[list[str]] = Field(
        None, description='Groups is the list of groups configured on the client.'
    )
    name: Optional[str] = Field(
        None, description='Name is the type of the client that was registered.'
    )


class CreateGroupRequest(BaseModel):
    name: Optional[str] = Field(None, description='Name of the group to create')


class CreateGroupResponse(BaseModel):
    name: Optional[str] = Field(None, description='Name of the created group')


class CreateSecretRequest(BaseModel):
    key: Optional[str] = Field(None, description='Secret key name')
    value: Optional[str] = Field(None, description='Secret value')


class CreateSecretResponse(BaseModel):
    key: Optional[str] = Field(None, description='Secret key that was created')
    message: Optional[str] = Field(None, description='Success message')


class CreateWorkloadResponse(BaseModel):
    name: Optional[str] = Field(None, description='Name of the created workload')
    port: Optional[int] = Field(None, description='Port the workload is listening on')


class GroupListResponse(BaseModel):
    groups: Optional[list[groups_1.Group]] = Field(None, description='List of groups')


class OidcOptions(BaseModel):
    audience: Optional[str] = Field(None, description='Expected audience')
    client_id: Optional[str] = Field(None, description='OAuth2 client ID')
    client_secret: Optional[str] = Field(None, description='OAuth2 client secret')
    introspection_url: Optional[str] = Field(
        None, description='Token introspection URL for OIDC'
    )
    issuer: Optional[str] = Field(None, description='OIDC issuer URL')
    jwks_url: Optional[str] = Field(None, description='JWKS URL for key verification')


class ProviderCapabilitiesResponse(BaseModel):
    can_cleanup: Optional[bool] = Field(
        None, description='Whether the provider can cleanup all secrets'
    )
    can_delete: Optional[bool] = Field(
        None, description='Whether the provider can delete secrets'
    )
    can_list: Optional[bool] = Field(
        None, description='Whether the provider can list secrets'
    )
    can_read: Optional[bool] = Field(
        None, description='Whether the provider can read secrets'
    )
    can_write: Optional[bool] = Field(
        None, description='Whether the provider can write secrets'
    )


class RegistryInfo(BaseModel):
    last_updated: Optional[str] = Field(None, description='Last updated timestamp')
    name: Optional[str] = Field(None, description='Name of the registry')
    server_count: Optional[int] = Field(
        None, description='Number of servers in the registry'
    )
    source: Optional[str] = Field(
        None,
        description='Source of the registry (URL, file path, or empty string for built-in)',
    )
    type: Optional[str] = Field(
        None, description='Type of registry (file, url, or default)'
    )
    version: Optional[str] = Field(None, description='Version of the registry schema')


class RegistryListResponse(BaseModel):
    registries: Optional[list[RegistryInfo]] = Field(
        None, description='List of registries'
    )


class RemoteOAuthConfig(BaseModel):
    authorize_url: Optional[str] = Field(
        None,
        description='OAuth authorization endpoint URL (alternative to issuer for non-OIDC OAuth)',
    )
    callback_port: Optional[int] = Field(
        None, description='Specific port for OAuth callback server'
    )
    client_id: Optional[str] = Field(
        None, description='OAuth client ID for authentication'
    )
    client_secret: Optional[secrets_1.SecretParameter] = None
    issuer: Optional[str] = Field(
        None, description='OAuth/OIDC issuer URL (e.g., https://accounts.google.com)'
    )
    oauth_params: Optional[dict[str, str]] = Field(
        None,
        description='Additional OAuth parameters for server-specific customization',
    )
    scopes: Optional[list[str]] = Field(None, description='OAuth scopes to request')
    skip_browser: Optional[bool] = Field(
        None,
        description='Whether to skip opening browser for OAuth flow (defaults to false)',
    )
    token_url: Optional[str] = Field(
        None,
        description='OAuth token endpoint URL (alternative to issuer for non-OIDC OAuth)',
    )
    use_pkce: Optional[bool] = Field(
        None, description='Whether to use PKCE for the OAuth flow'
    )


class SecretKeyResponse(BaseModel):
    description: Optional[str] = Field(
        None, description='Optional description of the secret'
    )
    key: Optional[str] = Field(None, description='Secret key name')


class SetupSecretsRequest(BaseModel):
    password: Optional[str] = Field(
        None,
        description='Password for encrypted provider (optional, can be set via environment variable)\nTODO Review environment variable for this',
    )
    provider_type: Optional[str] = Field(
        None, description='Type of the secrets provider (encrypted, 1password, none)'
    )


class SetupSecretsResponse(BaseModel):
    message: Optional[str] = Field(None, description='Success message')
    provider_type: Optional[str] = Field(
        None, description='Type of the secrets provider that was setup'
    )


class ToolOverride(BaseModel):
    description: Optional[str] = Field(None, description='Description of the tool')
    name: Optional[str] = Field(None, description='Name of the tool')


class UpdateSecretRequest(BaseModel):
    value: Optional[str] = Field(None, description='New secret value')


class UpdateSecretResponse(BaseModel):
    key: Optional[str] = Field(None, description='Secret key that was updated')
    message: Optional[str] = Field(None, description='Success message')


class VersionResponse(BaseModel):
    version: Optional[str] = None


class WorkloadStatusResponse(BaseModel):
    status: Optional[str] = Field(None, description='Current status of the workload')


class CreateRequest(BaseModel):
    authz_config: Optional[str] = Field(None, description='Authorization configuration')
    cmd_arguments: Optional[list[str]] = Field(
        None, description='Command arguments to pass to the container'
    )
    env_vars: Optional[dict[str, str]] = Field(
        None, description='Environment variables to set in the container'
    )
    group: Optional[str] = Field(
        None, description='Group name this workload belongs to'
    )
    headers: Optional[list[registry_1.Header]] = None
    host: Optional[str] = Field(None, description='Host to bind to')
    image: Optional[str] = Field(None, description='Docker image to use')
    name: Optional[str] = Field(None, description='Name of the workload')
    network_isolation: Optional[bool] = Field(
        None,
        description='Whether network isolation is turned on. This applies the rules in the permission profile.',
    )
    oauth_config: Optional[RemoteOAuthConfig] = None
    oidc: Optional[OidcOptions] = None
    permission_profile: Optional[permissions.Profile] = None
    proxy_mode: Optional[str] = Field(None, description='Proxy mode to use')
    proxy_port: Optional[int] = Field(
        None, description='Port for the HTTP proxy to listen on'
    )
    secrets: Optional[list[secrets_1.SecretParameter]] = Field(
        None, description='Secret parameters to inject'
    )
    target_port: Optional[int] = Field(
        None, description='Port to expose from the container'
    )
    tools: Optional[list[str]] = Field(None, description='Tools filter')
    tools_override: Optional[dict[str, ToolOverride]] = Field(
        None, description='Tools override'
    )
    transport: Optional[str] = Field(None, description='Transport configuration')
    url: Optional[str] = Field(None, description='Remote server specific fields')
    volumes: Optional[list[str]] = Field(None, description='Volume mounts')


class GetSecretsProviderResponse(BaseModel):
    capabilities: Optional[ProviderCapabilitiesResponse] = None
    name: Optional[str] = Field(None, description='Name of the secrets provider')
    provider_type: Optional[str] = Field(
        None, description='Type of the secrets provider'
    )


class ListSecretsResponse(BaseModel):
    keys: Optional[list[SecretKeyResponse]] = Field(
        None, description='List of secret keys'
    )


class UpdateRequest(BaseModel):
    authz_config: Optional[str] = Field(None, description='Authorization configuration')
    cmd_arguments: Optional[list[str]] = Field(
        None, description='Command arguments to pass to the container'
    )
    env_vars: Optional[dict[str, str]] = Field(
        None, description='Environment variables to set in the container'
    )
    group: Optional[str] = Field(
        None, description='Group name this workload belongs to'
    )
    headers: Optional[list[registry_1.Header]] = None
    host: Optional[str] = Field(None, description='Host to bind to')
    image: Optional[str] = Field(None, description='Docker image to use')
    network_isolation: Optional[bool] = Field(
        None,
        description='Whether network isolation is turned on. This applies the rules in the permission profile.',
    )
    oauth_config: Optional[RemoteOAuthConfig] = None
    oidc: Optional[OidcOptions] = None
    permission_profile: Optional[permissions.Profile] = None
    proxy_mode: Optional[str] = Field(None, description='Proxy mode to use')
    proxy_port: Optional[int] = Field(
        None, description='Port for the HTTP proxy to listen on'
    )
    secrets: Optional[list[secrets_1.SecretParameter]] = Field(
        None, description='Secret parameters to inject'
    )
    target_port: Optional[int] = Field(
        None, description='Port to expose from the container'
    )
    tools: Optional[list[str]] = Field(None, description='Tools filter')
    tools_override: Optional[dict[str, ToolOverride]] = Field(
        None, description='Tools override'
    )
    transport: Optional[str] = Field(None, description='Transport configuration')
    url: Optional[str] = Field(None, description='Remote server specific fields')
    volumes: Optional[list[str]] = Field(None, description='Volume mounts')


class WorkloadListResponse(BaseModel):
    workloads: Optional[list[core.Workload]] = Field(
        None, description='List of container information for each workload'
    )


class GetServerResponse(BaseModel):
    is_remote: Optional[bool] = Field(
        None, description='Indicates if this is a remote server'
    )
    remote_server: Optional[registry_1.RemoteServerMetadata] = None
    server: Optional[registry_1.ImageMetadata] = None


class ListServersResponse(BaseModel):
    remote_servers: Optional[list[registry_1.RemoteServerMetadata]] = Field(
        None, description='List of remote servers in the registry (if any)'
    )
    servers: Optional[list[registry_1.ImageMetadata]] = Field(
        None, description='List of container servers in the registry'
    )


class GetRegistryResponse(BaseModel):
    last_updated: Optional[str] = Field(None, description='Last updated timestamp')
    name: Optional[str] = Field(None, description='Name of the registry')
    registry: Optional[registry_1.Registry] = None
    server_count: Optional[int] = Field(
        None, description='Number of servers in the registry'
    )
    source: Optional[str] = Field(
        None,
        description='Source of the registry (URL, file path, or empty string for built-in)',
    )
    type: Optional[str] = Field(
        None, description='Type of registry (file, url, or default)'
    )
    version: Optional[str] = Field(None, description='Version of the registry schema')
